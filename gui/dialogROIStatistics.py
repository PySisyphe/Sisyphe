"""
    External packages/modules

        Name            Link                                                        Usage

        Matplotlib      https://matplotlib.org/                                     Plotting library
        Numpy           https://numpy.org/                                          Scientific computing
        pandas          https://pandas.pydata.org/                                  Data analysis and manipulation tool
        PyQt5           https://www.riverbankcomputing.com/software/pyqt/           Qt GUI
"""

from os import remove
from os.path import join
from os.path import exists
from os.path import dirname
from os.path import basename
from os.path import splitext

from numpy import array
from numpy import where
from numpy import histogram

from pandas import DataFrame
from pandas import concat

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

from PyQt5.QtCore import Qt
from PyQt5.QtGui import QIcon
from PyQt5.QtGui import QBrush
from PyQt5.QtGui import QPixmap
from PyQt5.QtWidgets import QWidget
from PyQt5.QtWidgets import QMenu
from PyQt5.QtWidgets import QAction
from PyQt5.QtWidgets import QDialog
from PyQt5.QtWidgets import QMessageBox
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout
from PyQt5.QtWidgets import QTreeWidget
from PyQt5.QtWidgets import QHeaderView
from PyQt5.QtWidgets import QTreeWidgetItem
from PyQt5.QtWidgets import QLabel
from PyQt5.QtWidgets import QPushButton
from PyQt5.QtWidgets import QComboBox
from PyQt5.QtWidgets import QTabWidget
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtWidgets import QApplication

from Sisyphe.core.sisypheSheet import SisypheSheet
from Sisyphe.core.sisypheVolume import SisypheVolume
from Sisyphe.core.sisypheROI import SisypheROICollection
from Sisyphe.core.sisypheROI import SisypheROIDraw
from Sisyphe.core.sisypheROI import SisypheROIFeatures

"""
    Class
    
        DialogROIStatistics
"""


class DialogROIStatistics(QDialog):
    """
        DialogROIStatistics class

        Inheritance

            QWidget - > QDialog -> DialogROIStatistics

        Private attributes

            _rois           SisypheROICollection
            _volume         SisypheVolume
            _stats          DataFrame, descriptive statistics for each roi
            _shape          DataFrame, shape features for each roi
            _hists          DataFrame, histograms for each roi
            _moveFlag       bool, move flag for matplotlib move event
            _bins           int, number of bins histogram
            _tol            float, pick tolerance around vertical line
            _histplots      list matplotlib artists generated by matplotlib.axes.hist(), for visibility control
            _cumhistplots   list matplotlib artists generated by matplotlib.axes.plot(), for visibility control
            _boxplots       list matplotlib artists generated by matplotlib.axes.boxplot(), for visibility control

        Public methods

            _updateStatTab()
            setVolume(SisypheVolume)
            SisypheVolume = getVolume()
            bool = hasVolume()
            setROICollection(SisypheROICollection)
            SisypheROICollection = getROICollection()
            bool = hasROICollection()

            inherited QDialog methods
            inherited QWidget methods
    """
    _DEFAULTBINS = 1

    def __init__(self, parent=None):
        super().__init__(parent)

        # Class attributes

        self._rois = None
        self._volume = None
        self._stats = None
        self._shape = None
        self._hists = None
        self._moveFlag = False
        self._tol = None
        self._histplots = None
        self._cumhistplots = None
        self._boxplots = None

        # Init QLayout

        self._layout = QVBoxLayout()
        self._layout.setContentsMargins(0, 0, 0, 0)
        self._layout.setSpacing(0)
        self.setLayout(self._layout)

        # Init QMenu

        self._menusavefig = QMenu()
        self._action = dict()

        self._action['savechart1'] = QAction('Save current chart', self)
        self._action['savechart2'] = QAction('Save current chart as...', self)
        self._action['saveallcharts1'] = QAction('Save all charts', self)
        self._action['saveallcharts2'] = QAction('Save all charts as...', self)
        self._action['savechart1'].triggered.connect(lambda: self._saveFig(default=True))
        self._action['savechart2'].triggered.connect(lambda: self._saveFig(default=False))
        self._action['saveallcharts1'].triggered.connect(lambda: self._saveAllFig(default=True))
        self._action['saveallcharts2'].triggered.connect(lambda: self._saveAllFig(default=False))
        self._menusavefig.addAction(self._action['savechart1'])
        self._menusavefig.addAction(self._action['savechart2'])
        self._menusavefig.addAction(self._action['saveallcharts1'])
        self._menusavefig.addAction(self._action['saveallcharts2'])

        self._menusavestats = QMenu()
        self._action['savestats1'] = QAction('Save current statistics', self)
        self._action['savestats2'] = QAction('Save current statistics as...', self)
        self._action['saveallstats1'] = QAction('Save all statistics', self)
        self._action['saveallstats2'] = QAction('Save all statistics as...', self)
        self._action['savehists1'] = QAction('Save histograms', self)
        self._action['savehists2'] = QAction('Save histograms as...', self)
        self._action['savestats1'].triggered.connect(lambda: self._saveStats(default=True))
        self._action['savestats2'].triggered.connect(lambda: self._saveStats(default=False))
        self._action['saveallstats1'].triggered.connect(lambda: self._saveAllStats(default=True))
        self._action['saveallstats2'].triggered.connect(lambda: self._saveAllStats(default=False))
        self._action['savehists1'].triggered.connect(lambda: self._saveHistograms(default=True))
        self._action['savehists2'].triggered.connect(lambda: self._saveHistograms(default=False))
        self._menusavestats.addAction(self._action['savestats1'])
        self._menusavestats.addAction(self._action['savestats2'])
        self._menusavestats.addAction(self._action['saveallstats1'])
        self._menusavestats.addAction(self._action['saveallstats2'])
        self._menusavestats.addAction(self._action['savehists1'])
        self._menusavestats.addAction(self._action['savehists2'])

        # Init widgets

        self.setWindowTitle('ROI statistics')

        background = self.palette().window().color()
        self._graphtab = QTabWidget()

        self._histtab = QWidget()
        self._histfig = Figure()
        self._histfig.set_facecolor((background.red() / 255,
                                     background.green() / 255,
                                     background.blue() / 255))
        self._histcanvas = FigureCanvas(self._histfig)
        lyout = QHBoxLayout()
        lyout.setContentsMargins(0, 0, 0, 0)
        lyout.addWidget(self._histcanvas)
        self._histtab.setLayout(lyout)

        self._cumhisttab = QWidget()
        self._cumhistfig = Figure()
        self._cumhistfig.set_facecolor((background.red() / 255,
                                        background.green() / 255,
                                        background.blue() / 255))
        self._cumhistcanvas = FigureCanvas(self._cumhistfig)
        lyout = QHBoxLayout()
        lyout.setContentsMargins(0, 0, 0, 0)
        lyout.addWidget(self._cumhistcanvas)
        self._cumhisttab.setLayout(lyout)
        self._line = None
        self._label = None

        self._plottab = QWidget()
        self._plotfig = Figure()
        self._plotfig.set_facecolor((background.red() / 255,
                                     background.green() / 255,
                                     background.blue() / 255))
        self._plotcanvas = FigureCanvas(self._plotfig)
        lyout = QHBoxLayout()
        lyout.setContentsMargins(0, 0, 0, 0)
        lyout.addWidget(self._plotcanvas)
        self._plottab.setLayout(lyout)

        self._graphtab.addTab(self._histtab, 'Histogram')
        self._graphtab.addTab(self._cumhisttab, 'Cumulative histogram')
        self._graphtab.addTab(self._plottab, 'Box and whisker chart')
        self._layout.addWidget(self._graphtab)

        self._stattab = QTabWidget()

        self._graytab = QWidget()
        self._graylist = QTreeWidget()
        self._graylist.setSelectionMode(1)
        self._graylist.setHeaderLabels(['Name', 'Color', 'Voxels', 'Volume (cc)', 'Mean', 'Median', 'Min.', 'Max.',
                                        'Range', 'Perc. 25', 'Perc. 75', 'Variance', 'Std Dev.', 'Skewness',
                                        'Kurtosis'])
        for i in range(self._graylist.headerItem().columnCount()):
            self._graylist.headerItem().setTextAlignment(i, Qt.AlignCenter)
        self._graylist.header().setSectionResizeMode(QHeaderView.ResizeToContents)
        self._graylist.header().setSectionsClickable(False)
        self._graylist.header().setSortIndicatorShown(False)
        self._graylist.header().setStretchLastSection(False)
        self._graylist.setAlternatingRowColors(True)
        self._graylist.invisibleRootItem()
        lyout = QHBoxLayout()
        lyout.setContentsMargins(0, 0, 0, 0)
        lyout.addWidget(self._graylist)
        self._graytab.setLayout(lyout)

        self._shapetab = QWidget()
        self._shapelist = QTreeWidget()
        self._shapelist.setSelectionMode(1)
        self._shapelist.setHeaderLabels(['Name', 'Color', 'Volume (cc)', 'Surface', 'Surface/volume\nratio',
                                         'Sphericity', 'Max.\ndiameter', 'Max. axial\ndiameter',
                                         'Max. coronal\ndiameter', 'Max. sagittal\ndiameter', 'Major axis\nlength',
                                         'Minor axis\nlength', 'Least axis\nlength', 'Elongation', 'Flatness'])
        for i in range(self._shapelist.headerItem().columnCount()):
            self._shapelist.headerItem().setTextAlignment(i, Qt.AlignCenter)
        self._shapelist.header().setSectionResizeMode(QHeaderView.ResizeToContents)
        self._shapelist.header().setSectionsClickable(False)
        self._shapelist.header().setSortIndicatorShown(False)
        self._shapelist.header().setStretchLastSection(False)
        self._shapelist.setAlternatingRowColors(True)
        self._shapelist.invisibleRootItem()
        lyout = QHBoxLayout()
        lyout.setContentsMargins(0, 0, 0, 0)
        lyout.addWidget(self._shapelist)
        self._shapetab.setLayout(lyout)

        self._stattab.addTab(self._graytab, 'Gray levels statistics')
        self._stattab.addTab(self._shapetab, 'Shape features')
        self._layout.addWidget(self._stattab)

        buttonlyout = QHBoxLayout()
        buttonlyout.setContentsMargins(5, 0, 0, 0)
        buttonlyout.setSpacing(5)
        self._bins = QComboBox()
        self._bins.setFixedWidth(75)
        for i in range(50, 550, 50): self._bins.addItem(str(i))
        self._bins.setCurrentIndex(self._DEFAULTBINS)
        self._savefig = QPushButton('Save')
        self._savefig.setFixedWidth(100)
        self._savefig.setToolTip('Save chart(s) to BMP, JPG, PNG, TIFF or SVG format.')
        self._savefig.setMenu(self._menusavefig)
        self._copyfig = QPushButton('Copy')
        self._copyfig.setFixedWidth(100)
        self._copyfig.setToolTip('Copy current chart to clipboard.')
        self._copyfig.clicked.connect(self._copyFigToClipboard)
        self._savestats = QPushButton('Save')
        self._savestats.setFixedWidth(100)
        self._savestats.setToolTip('Save ROI statistics and shape features to CSV,\nJSON, Latex, Text, XLSX or PySisyphe xsheet format.')
        self._savestats.setMenu(self._menusavestats)
        buttonlyout.addWidget(QLabel('Bins'))
        buttonlyout.addWidget(self._bins)
        buttonlyout.addWidget(self._savefig)
        buttonlyout.addWidget(self._copyfig)
        buttonlyout.addWidget(self._savestats)
        buttonlyout.addStretch()
        self._layout.addLayout(buttonlyout)

        # Init default dialog buttons

        layout = QHBoxLayout()
        layout.setSpacing(10)
        layout.setDirection(QHBoxLayout.RightToLeft)
        ok = QPushButton('Close')
        ok.setFixedWidth(100)
        ok.setAutoDefault(True)
        ok.setDefault(True)
        layout.addWidget(ok)
        layout.addStretch()
        self._layout.addLayout(layout)

        # Init matplotlib events

        self._cumhistcanvas.mpl_connect('button_press_event', self._onMouseClickEvent)
        self._cumhistcanvas.mpl_connect('motion_notify_event', self._onMouseMoveEvent)
        self._cumhistcanvas.mpl_connect('button_release_event', self._onMouseReleaseEvent)

        # Qt Signals

        self._graylist.itemSelectionChanged.connect(self._selectionChanged)
        self._bins.currentIndexChanged.connect(self._binsChanged)
        ok.clicked.connect(self.accept)

        # Window

        self.setWindowModality(Qt.ApplicationModal)

    # Class method

    @classmethod
    def getDefaultIconDirectory(cls):
        import Sisyphe.gui
        return join(dirname(Sisyphe.gui.__file__), 'icons')

    # Private methods

    def _selectionChanged(self):
        if self._line is not None:
            x = self._line.get_xdata()[0]
            self._displayLineAt(x)

    def _checkStateChanged(self, item, c):
        if c == 0:
            index = self._graylist.indexOfTopLevelItem(item)
            index0 = index * 2
            index1 = index0 + 1
            v = item.checkState(0)
            for plot in self._histplots[index]: plot.set_visible(v)
            for plot in self._cumhistplots[index]: plot.set_visible(v)
            self._boxplots['whiskers'][index0].set_visible(v)
            self._boxplots['whiskers'][index1].set_visible(v)
            self._boxplots['caps'][index0].set_visible(v)
            self._boxplots['caps'][index1].set_visible(v)
            self._boxplots['boxes'][index].set_visible(v)
            self._boxplots['medians'][index].set_visible(v)
            self._histcanvas.draw()
            self._cumhistcanvas.draw()
            self._plotcanvas.draw()

    def _binsChanged(self):
        del self._line
        self._line = None
        self._histfig.clear()
        self._cumhistfig.clear()
        self._plotfig.clear()
        self._updatePlotTab()
        self._histcanvas.draw()
        self._cumhistcanvas.draw()
        self._plotcanvas.draw()

    def _displayLineAt(self, x):
        if isinstance(x, float):
            item = self._graylist.selectedItems()
            if item:
                name = item[0].text(0)
                c = self._rois[name].getColor()
                v = self._stats[name]['count'] * self._volume.getVoxelVolume() / 1000
                idx = array(self._hists[name]['index'])
                step = idx[1] - idx[0]
                if self._line is None:
                    ax2 = self._cumhistfig.get_axes()[0]
                    self._line = ax2.axvline(x, color=c, linewidth=2, ls='--')
                    y = self._gety(x)
                    if self._volume.isFloatDatatype():
                        txt = '{}\nValue {:.1f}\n{:.1f} %\n{:.4g} cc'.format(name, x, y * 100, v * y)
                    else: txt = '{}\nValue {}\n{:.1f} %\n{:.4g} cc'.format(name, int(x), y * 100, v * y)
                    self._label = ax2.annotate(txt, xy=(x + step, y), xycoords='data', color=c)
                else:
                    self._line.set_xdata([x, x])
                    self._line.set_color(c)
                    y = self._gety(x)
                    if self._volume.isFloatDatatype(): txt = 'Value {:.1f}\n{:.1f} %\n{:.4g} cc'.format(x, y * 100, v * y)
                    else: txt = '{}\nValue {}\n{:.1f} %\n{:.4g} cc'.format(name, int(x), self._gety(int(x)) * 100, v * y)
                    self._label.set_color(c)
                    self._label.xyann = [x + step, y]
                    self._label.set_text(txt)
                    self._cumhistcanvas.draw()
        else: raise TypeError('parameter type {} is not float.'.format(type(x)))

    def _gety(self, x):
        item = self._graylist.selectedItems()
        if item:
            c = array(self._hists[item[0].text(0)]['index'])
            if x > c.max(): return 0.0
            elif x < c.min(): return 1.0
            else:
                h = self._hists[item[0].text(0)]['cumhist']
                index = where(c > x)[0][0]
                # linear interpolation
                step = c[index] - c[index - 1]
                i = (c[index] - x) / step
                return i * h[index - 1] + (1 - i) * h[index]

    def _updateStatTab(self):
        if self.hasROICollection():
            if len(self._rois) > 0:
                self._graylist.clear()
                v = self._volume.getVoxelVolume()
                for roi in self._rois:
                    name = roi.getName()
                    # Gray level statistics
                    item = QTreeWidgetItem(self._graylist)
                    item.setText(0, name)
                    item.setCheckState(0, Qt.Checked)
                    item.setText(1, '')
                    item.setBackground(1, QBrush(roi.getQColor()))
                    item.setText(2, str(self._stats[name]['count']))
                    item.setText(3, '{:.2f}'.format(self._stats[name]['count'] * v / 1000))
                    item.setText(4, '{:.2f}'.format(self._stats[name]['mean']))
                    item.setText(5, '{:.2f}'.format(self._stats[name]['median']))
                    item.setText(6, '{:.2f}'.format(self._stats[name]['min']))
                    item.setText(7, '{:.2f}'.format(self._stats[name]['max']))
                    item.setText(8, '{:.2f}'.format(self._stats[name]['range']))
                    item.setText(9, '{:.2f}'.format(self._stats[name]['perc25']))
                    item.setText(10, '{:.2f}'.format(self._stats[name]['perc75']))
                    item.setText(11, '{:.2f}'.format(self._stats[name]['var']))
                    item.setText(12, '{:.2f}'.format(self._stats[name]['std']))
                    item.setText(13, '{:.2f}'.format(self._stats[name]['skewness']))
                    item.setText(14, '{:.2f}'.format(self._stats[name]['kurtosis']))
                    for i in range(item.columnCount()): item.setTextAlignment(i, Qt.AlignCenter)
                    self._graylist.addTopLevelItem(item)
                    # Shape features
                    item = QTreeWidgetItem(self._shapelist)
                    item.setText(0, name)
                    item.setTextAlignment(0, 4)
                    item.setText(1, '')
                    item.setBackground(1, QBrush(roi.getQColor()))
                    item.setText(2, '{:.2f}'.format(self._shape[name]['VoxelVolume'] / 1000))
                    item.setText(3, '{:.2f}'.format(self._shape[name]['SurfaceArea']))
                    item.setText(4, '{:.2f}'.format(self._shape[name]['SurfaceVolumeRatio']))
                    item.setText(5, '{:.2f}'.format(self._shape[name]['Sphericity']))
                    item.setToolTip(5, 'Sphericity is a measure of the roundness of the shape of the tumor region\n'
                                       'relative to a sphere. It is a dimensionless measure, independent of scale\n'
                                       'and orientation. The value range between 1 and 0, where a value of 1\n'
                                       'indicates a perfect sphere.')
                    item.setText(6, '{:.2f}'.format(self._shape[name]['Maximum3DDiameter']))
                    item.setText(7, '{:.2f}'.format(self._shape[name]['Maximum2DDiameterSlice']))
                    item.setText(8, '{:.2f}'.format(self._shape[name]['Maximum2DDiameterColumn']))
                    item.setText(9, '{:.2f}'.format(self._shape[name]['Maximum2DDiameterRow']))
                    item.setText(10, '{:.2f}'.format(self._shape[name]['MajorAxisLength']))
                    item.setText(11, '{:.2f}'.format(self._shape[name]['MinorAxisLength']))
                    item.setText(12, '{:.2f}'.format(self._shape[name]['LeastAxisLength']))
                    item.setText(13, '{:.2f}'.format(self._shape[name]['Elongation']))
                    item.setToolTip(13, 'Elongation shows the relationship between the two largest principal\n'
                                        'components in the ROI shape. The values range between 1 (where the\n'
                                        'cross section through the first and second largest principal moments\n'
                                        'is circle-like (non-elongated)) and 0 (where the object is a maximally\n'
                                        'elongated: i.e. a 1 dimensional line).')
                    item.setText(14, '{:.2f}'.format(self._shape[name]['Flatness']))
                    item.setToolTip(14, 'Flatness shows the relationship between the largest and smallest\n'
                                        'principal components in the ROI shape. The values range between 1\n'
                                        '(non-flat, sphere-like) and 0 (a flat object, or single-slice\n'
                                        'segmentation).')
                    for i in range(item.columnCount()): item.setTextAlignment(i, Qt.AlignCenter)
                self._graylist.topLevelItem(0).setSelected(True)
            else: raise AttributeError('ROI collection is empty.')
        else: raise AttributeError('ROI collection is not defined.')

    def _updatePlotTab(self):
        if self.hasROICollection():
            if len(self._rois) > 0:
                data = list()
                self._hists = dict()
                self._histplots = list()
                self._cumhistplots = list()
                ax1 = self._histfig.add_subplot(111)
                ax2 = self._cumhistfig.add_subplot(111)
                ax3 = self._plotfig.add_subplot(111)
                bins = int(self._bins.currentText())
                for roi in self._rois:
                    mask = roi.getNumpy().flatten() > 0
                    img = self._volume.getNumpy().flatten()[mask]
                    data.append(img)
                    # Histogram chart
                    plot = ax1.hist(img, bins, density=True, histtype='step', color=roi.getColor(), linewidth=2)
                    self._histplots.append(plot[2])
                    # Cumulative histogram chart
                    h, c = histogram(img, bins=bins)
                    s = h.sum()
                    hists = dict()
                    hists['hist'] = h
                    self._hists[roi.getName()] = hists
                    c = list((c[:-1] + c[1:]) / 2)
                    h = h[::-1].cumsum()[::-1] / s
                    hists['cumhist'] = h
                    hists['index'] = c
                    plot = ax2.plot(c, h, color=roi.getColor(), linewidth=2)
                    self._cumhistplots.append(plot)
                    self._hists[roi.getName()] = hists
                ax1.set(ylabel='Probability', xlabel='{} values'.format(basename(self._volume.getFilename())))
                ax1.grid()
                ax2.set(ylabel='Probability', xlabel='{} values'.format(basename(self._volume.getFilename())))
                self._displayLineAt(float(c[bins // 2]))
                ax2.grid()
                # Box and whisker chart
                self._boxplots = ax3.boxplot(data, vert=True, patch_artist=True, labels=self._rois.keys(),
                                             showfliers=False)
                index = 0
                for patch in self._boxplots['boxes']:
                    c = self._rois[index].getColor()
                    patch.set_facecolor(c)
                    index += 1
                ax3.yaxis.grid(True)
                ax3.set_xlabel('ROI')
                ax3.set_ylabel('{} values'.format(basename(self._volume.getFilename())))
            else: raise AttributeError('ROI collection is empty.')
        else: raise AttributeError('ROI collection is not defined.')

    def _saveFig(self, index=None, default=False):
        if index is None: index = self._graphtab.currentIndex()
        if index == 0:
            title = 'Save histogram chart'
            filename = splitext(self._volume.getFilename())[0] + '_Histogram.jpg'
        elif index == 1:
            title = 'Save cumulative histogram chart'
            filename = splitext(self._volume.getFilename())[0] + '_Cumulative_Histogram.jpg'
        else:
            title = 'Save Box and whisker chart'
            filename = splitext(self._volume.getFilename())[0] + '_Box_Whisker.jpg'
        if not default:
            filename = QFileDialog.getSaveFileName(self, title, filename,
                                                   filter='BMP (*.bmp);;JPG (*.jpg);;PNG (*.png);;'
                                                          'TIFF (*.tiff);;SVG (*.svg)',
                                                   initialFilter='JPG (*.jpg)')[0]
            QApplication.processEvents()
        if filename:
            try:
                if index == 0: self._histfig.savefig(filename)
                elif index == 1: self._cumhistfig.savefig(filename)
                else: self._plotfig.savefig(filename)
                if default: QMessageBox.warning(self, 'Save chart',
                                                '{} saved to {} filepath.'.format(basename(filename), dirname(filename)))
            except Exception as msg:
                QMessageBox.warning(self, 'Save {} error'.format(basename(filename)), '{}'.format(msg))

    def _saveAllFig(self, default=False):
        for i in range(3): self._saveFig(i, default)

    def _copyFigToClipboard(self):
        index = self._graphtab.currentIndex()
        tmp = join(dirname(self._volume.getFilename()), 'tmp.png')
        try:
            if index == 0: self._histfig.savefig(tmp)
            elif index == 1: self._cumhistfig.savefig(tmp)
            else: self._plotfig.savefig(tmp)
            img = QPixmap(tmp)
            QApplication.clipboard().setPixmap(img)
        except Exception as msg:
            QMessageBox.warning(self, 'Copy to clipboard error', '{}'.format(msg))
        finally:
            if exists(tmp): remove(tmp)

    def _saveStats(self, index=None, default=False):
        if index is None: index = self._stattab.currentIndex()
        if index == 0:
            title = 'Save descriptive statistics'
            filename = filename = splitext(self._volume.getFilename())[0] + '_Statistics.csv'
        else:
            title = 'Save shape features'
            filename = filename = splitext(self._volume.getFilename())[0] + '_Shape.csv'
        if not default:
            filename = QFileDialog.getSaveFileName(self, title, filename,
                                                   filter='CSV (*.csv);; '
                                                          'JSON (*.json);; '
                                                          'Latex (*.tex);; '
                                                          'Text (*.txt);; '
                                                          'XLSX (*.xlsx);; '
                                                          'PySisyphe Sheet (*.xsheet)',
                                                   initialFilter='CSV (*.csv)')[0]
            QApplication.processEvents()
        if filename:
            if index == 0: sheet = SisypheSheet(DataFrame(self._stats))
            else: sheet = SisypheSheet(DataFrame(self._shape))
            ext = splitext(filename)[1][1:]
            try:
                if ext == 'csv': sheet.saveCSV(filename)
                elif ext == 'json': sheet.saveJSON(filename)
                elif ext == 'tex': sheet.saveLATEX(filename)
                elif ext == 'txt': sheet.saveTXT(filename)
                elif ext == 'xlsx': sheet.saveXLSX(filename)
                elif ext == 'xsheet': sheet.save(filename)
                else: raise ValueError('{} format is not supported.'.format(ext))
                if default: QMessageBox.warning(self, 'Save statistics',
                                                '{} saved to {} filepath.'.format(basename(filename), dirname(filename)))
            except Exception as msg:
                QMessageBox.warning(self, 'Save {} error'.format(basename(filename)), '{}'.format(msg))

    def _saveAllStats(self, default=False):
        for i in range(2): self._saveStats(i, default)
        self._saveHistograms(default)

    def _saveHistograms(self, default=False):
        filename = join(dirname(self._volume.getFilename()), 'Histograms.csv')
        if not default:
            filename = QFileDialog.getSaveFileName(self, 'Save histograms', filename,
                                                   filter='CSV (*.csv);;XLSX (*.xlsx)',
                                                   initialFilter='CSV (*.csv)')[0]
            QApplication.processEvents()
        if filename:
            ext = splitext(filename)[1][1:]
            try:
                groups = list(self._hists.keys())
                hists = list()
                for k in self._hists.keys():
                    hists.append(DataFrame(self._hists[k]))
                df = concat(hists, keys=groups)
                if ext == 'csv': df.to_csv(filename)
                else: df.to_excel(filename)
                if default: QMessageBox.warning(self, 'Save histograms',
                                                '{} saved to {} filepath.'.format(basename(filename), dirname(filename)))
            except Exception as msg:
                QMessageBox.warning(self, 'Save {} error'.format(basename(filename)), '{}'.format(msg))

    # Private matplotlib event methods

    def _onMouseClickEvent(self, event):
        ax = self._cumhistfig.get_axes()[0]
        if event.inaxes == ax:
            if -self._tol < event.xdata - self._line.get_xdata()[0] < self._tol:
                self._moveFlag = True

    def _onMouseMoveEvent(self, event):
        ax = self._cumhistfig.get_axes()[0]
        if event.inaxes == ax:
            if self._moveFlag:
                x = event.xdata
                inf, sup = self._volume.getDisplay().getRange()
                if x < inf: x = float(inf)
                elif x > sup: x = float(sup)
                self._displayLineAt(x)

    def _onMouseReleaseEvent(self, event):
        self._moveFlag = False

    # Public methods

    def setVolume(self, volume):
        if isinstance(volume, SisypheVolume):
            self._volume = volume
            self._tol = (self._volume.display.getRangeMax() -
                         self._volume.display.getRangeMin()) / 100
            if self.hasROICollection() and len(self._rois) > 0:
                if self._rois[0].getReferenceID() != self._volume.getID(): self._rois = None
        else:
            raise TypeError('parameter type {} is not SisypheVolume.'.format(type(volume)))

    def getVolume(self):
        return self._volume

    def hasVolume(self):
        return self._volume is not None

    def setROICollection(self, rois):
        if isinstance(rois, SisypheROICollection):
            if self.hasVolume:
                if len(rois) > 0:
                    # Descriptive statistics
                    flt = SisypheROIDraw()
                    flt.setVolume(self._volume)
                    self._stats = dict()
                    self._rois = SisypheROICollection()
                    self._rois.setReferenceID(self._volume)
                    for roi in rois:
                        if roi.getReferenceID() != self._volume.getID():
                            QMessageBox.warning(self, 'ROI statistics', 'ROI {} ID is not same as reference volume.'
                                                .format(roi.getName()))
                            continue
                        elif roi.getNumpy().sum() == 0:
                            QMessageBox.warning(self, 'ROI statistics', 'ROI {} array is empty.'
                                                .format(roi.getName()))
                            continue
                        else: self._rois.append(roi)
                        flt.setROI(roi)
                        self._stats[roi.getName()] = flt.getIntensityStatistics()
                    # Shape statistics
                    if len(self._rois) > 0:
                        flt = SisypheROIFeatures()
                        flt.setVolume(self._volume)
                        flt.setROICollection(self._rois)
                        flt.setShapeTag(True)
                        flt.execute()
                        self._shape = flt.getDataFrame().to_dict(orient='index')
                        self._updateStatTab()
                        self._updatePlotTab()
                        self._graylist.itemChanged.connect(self._checkStateChanged)
                else: raise ValueError('ROI collection is empty.')
            else: raise AttributeError('SisypheVolume attribute is not defined.')
        else: raise TypeError('parameter type {} is not SisypheROICollection.'.format(type(rois)))

    def getROICollection(self):
        return self._rois

    def hasROICollection(self):
        return self._rois is not None


"""
    Test
"""

if __name__ == '__main__':

    from sys import argv
    from Sisyphe.core.sisypheROI import SisypheROI

    app = QApplication(argv)
    vol1 = SisypheVolume()
    vol1.load('/Users/Jean-Albert/PycharmProjects/untitled/TESTS/ROI/STEREO3D.xvol')
    roi1 = SisypheROI()
    roi1.load('/Users/Jean-Albert/PycharmProjects/untitled/TESTS/ROI/testroi1.xroi')
    roi2 = SisypheROI()
    roi2.load('/Users/Jean-Albert/PycharmProjects/untitled/TESTS/ROI/testroi2.xroi')
    rois1 = SisypheROICollection()
    rois1.append(roi1)
    rois1.append(roi2)
    main = DialogROIStatistics()
    main.setVolume(vol1)
    main.setROICollection(rois1)
    main.show()
    app.exec_()
